% В отчете зачем-то требуется написать текст определенного
% объема, поэтому шрифт по умолчанию увеличен на 2pt.
\documentclass[14pt, a4paper]{extreport}

\usepackage{fullpage}
\usepackage{multicol, multirow}
\usepackage{tabularx}
\usepackage{standalone}
\usepackage{listings}
\usepackage{ulem}
\usepackage{amsmath}
\usepackage{pdfpages}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\newcommand{\StudentName}{Ильвохин Дмитрий}
\newcommand{\Group}{1O-106М}
\newcommand{\CourseName}{Сетевое программирование}
\newcommand{\TaskNum}{6}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}


\begin{document}

\include{title} % title page

\lstset
{
        language=Python,
        basicstyle=\footnotesize,% basic font setting
        extendedchars=\true
}

\section*{Лабораторная работа \#1}
\subsection*{Задание}
Разработать тонкого клиента к тестовой серверной базе данных.
Клиент должен позволять просматривать данные из таблиц сервера и кэшировать их.
Должна быть возможность работать в режиме оффлайн, при этом просматриваются лишь закэшированные данные.

\subsection*{Практическая часть}
В качестве серверной базы данных используется CouchDB --- документо-ориентированная система
управления базами данных. Для хранения данных в CouchDB используется JSON, в общем-то поэтому
и была выбрана именно эта система управления базами данных.

Локальное хранилище реализовано с помощью IndexedDB, которую вроде как, должны поддерживать
все современные браузеры.

Логика работы следующая: по умолчанию ничего не загружено, пользователь может выбрать какую базу загрузить
и источник загрузки (локальное или серверное хранилище).
При обращении к серверной БД данные кэшируются на клиенте, каждая база в своем хранилище.
Все запросы сделал асинхронными, чтобы страничка не фризилась при загрузке данных.
Это повлияло на читаемость кода, из-за многочисленных callback'ов временами стал путаться
что и откуда вызывается.

Все обращения к БД (локальной и серверной) постарался инкапсулировать к классы.
Для обращения к каждой базе был написан свой класс, которые использовались в главном
<<кэширующем>> классе.

Недоступность базы данных эмулируется искусственно, выставляется заведомо маленький request-таймаут,
чтобы база, даже с localhost'a не успела ответить.

Пример реализации получения данных из серверной БД:
\begin{lstlisting}[language=JavaScript]
// server db
function CouchDbViewer(dbName, forceTimeout) {
  this.dbName = dbName;
  this.forceTimeout = forceTimeout;
  this.requestPath = '/' + this.dbName + '/_all_docs';
}

CouchDbViewer.prototype.getData = function (successCallback, timeoutCallback) {
  var request = new XMLHttpRequest();
  request.ontimeout = timeoutCallback;

  request.open('GET', this.requestPath);

  if( this.forceTimeout ) {
    request.timeout = 1;
  }

  request.onload = function() {
    if( request.status != 200 ) {
      console.log('CouchDB request failed: ' + request.statusText);
      return;
    }
    successCallback(request.responseText);
  }

  request.send(null);
}
\end{lstlisting}


\subsection*{Выводы}
До выполнения лабораторной работы никогда не писал на JavaScript'e,
это был первый опыт подобного рода, было довольно интересно.
При знакомстве с JS удивило, что почти на каждый вопрос про то,
как сделать что-то на <<чистом>> JavaScript'e половина ответов посвящена
тому как это сделать с помощью разнообразных фреймворков.

Возможно, перед тем как начать писать нужно было почитать какие-нибудь лучшие практики
и правильные подходы, чтобы избежать паутины из callback'ов, которая получилась у меня.

\section*{Лабораторная работа \#2}
\subsection*{Задание}
Спроектировать сайт анекдотов, у которого будут следующие возможности:
\begin{itemize}
\item регистрация пользователей,
\item иерархия доступа (админ и обычный пользователь),
\item управление (CRUD) анекдотами для админов,
\item лента анекдотов для пользователей и гостей,
\item управление (CRUD) тегами (для админов),
\item прикрепление любого количества тегов к одному анекдоту,
\item избранные анекдоты,
\item like счетчик для каждого анекдота.

\end{itemize}
\subsection*{Практическая часть}
Для разработки сайта анекдотов решил использовать язык программирования
Python 2.7, так как был немного знаком с ним и он представляет широкие возможности
для быстрой разработки за счет своей богатой стандартной библиотеки.
Несмотря на то, что все прогрессивное человечество постепенно переходит
на Python 3 решил использовать более знакомую для себя версию в целях
экономии времени.

В качестве фреймворка для создания веб-приложений был выбран Flask, который
на первый взгляд показался дружелюбнее, чем Django.

Для хранения данных выбрал документо-ориентированную систему управления базами
данных CouchDB так как уже имел некоторый опыт работы с ней в лабораторной работе
\# 1.

Для хранения в базе данных приложения были выделены следующие сущности:
\begin{itemize}
\item Пользователь (User) --- непосредственный пользователь приложения.
\item Запись (Post) --- одна запись в ленте сайта, содержащая анекдот.
\end{itemize}

Для взаимодействия приложения и БД выбрал библиотеку couchdbkit, с помощью
которой можно легко отображать CouchDB объекты на объекты Python'a
(аналогично ORM, но с некоторыми особенностями для работы с CouchDB).

\subsection*{Выводы}
Познакомился с некоторыми самыми популярными веб-фреймворками для языка программирования
Python, попытался понять их слабые и сильные стороны конкретно для моих целей.
Постарался выбрать из них самый подходящий для моей задачи и используемых технологий,
одновременно с этим максимально гибкий и накладывающий наименьшее количество ограничений.

\section*{Лабораторная работа \#3}
\subsection*{Задание}
Разработать возможность регистрации и входа/выхода пользователей на сайт.

\subsection*{Практическая часть}
Решил не изобретать велосипед и использовать стандартную форму регистрации
с тремя полями: именем пользователя, паролем и подтверждением пароля.

Подумал, что для моих целей не нужны какие-то особые библиотеки для валидации форм,
ведь у меня нет каких-то особенных полей для ввода типа адреса электронной почты или
номера телефона, которые могу потребовать сложной логики валидации входных данных.
И я смогу валидировать все какими-нибудь своими простыми и понятными функциями.
Наверное, это главная и самая большая ошибка во всей лабораторной работе, которая
повлекла за собой большое количество неудобств в будущем.

Для верстки форм потребовалось изучить основы шаблонизатора Jinja2, который используется
во Flask'e и немного CSS'a. С основами шаблонизатора получилось разобраться довольно
быстро, чего нельзя сказать про CSS, вопросы по которому остались до сих пор.

Неверный выбор (точнее решение не использовать вовсе) библиотеки для валидации форм
повлекло за собой некоторые неприятные особенности уже на этом шаге.
Например, при неправильном заполнении какого-то поля в форме, после валидации на сервере
форма очищается. Такое поведение очень раздражало меня на множестве сайтов и я не понимал
как можно умудриться сделать так неудачно. В итоге сделал так сам.

Из интересных особенностей на этом шаге стоит отметить <<соль>> пароля.
Решил, что хранить пользовательские пароли на моем сервере недостаточно безопасно,
поэтому решил хранить соль и хэш от соли и пароля.

\begin{lstlisting}
def make_password_hash(salt, password):
  return hashlib.md5(salt + password).hexdigest()

def make_user_from_request(request):
  # we don't store real password for security reason
  salt = uuid.uuid4().hex
  password = make_password_hash(salt, request.form['password'])
  return User(username = request.form['username'],
    salt = salt,
    password = password,
    privileged = False,
    starred = [])
\end{lstlisting}

\subsection*{Выводы}
После выполнения лабораторной работы понял, что нужно использовать
готовые библиотеки для работы с формами и их валидации. Они существенно
упрощают жизнь и сильно экономят время, позволяя решать возникающие проблемы
намного проще.

\section*{Лабораторная работа \#4}
\subsection*{Задание}
Разработать ленту анекдотов для пользователей и гостей.

\subsection*{Практическая часть}
По задумке лента --- первое что увидит пользователь на сайте, поэтому
хотелось сделать ее максимально красивой, для этого пришлось применить
все мои не очень богатые знания CSS.

Кроме того, в последствии шаблон для показа постов стал более универсальным,
потому что стал использоваться на страницах с фильтрами для постов, например,
на странице с тегами, лайками и избранным.

Для зарегистрированных и залогиненных  пользователей было решено показывать
дополнительное поле --- возможность добавить новый анекдот.
К сожалению эта форма обладала всеми теми же недостатками, которые были описаны в
предыдущей части.

Чтобы не мешать все в одну кучу (добавление и показ новых постов (анекдотов))
решил вынести добавление нового поста на отдельный <<app.route>>. Пока не удалось
осознать до конца на сколько это было хорошей идеей, но, кажется, что код стал более читаемым,
не появилось никаких больших if'ов, обрабатывающий случай POST-запроса, в результате обе функции
выглядят максимально просто.

\begin{lstlisting}
@app.route('/')
def show_posts():
  posts = list(Post.view('posts/by_date'))[::-1]
  return render_template('main.html', posts = posts, submit = 'Share')

@app.route('/add_post', methods = ['POST'])
@login_required
def add_post():
  new_post = make_post_from_request(request)
  g.db.save_doc(new_post)

  flash('New post was successfully created')
  return redirect(url_for('show_posts'))
\end{lstlisting}

\subsection*{Выводы}
Осознал полезность include директивы шаблонизатора Jinja, с помощью
которой можно включать какую-то универсальную часть шаблона в другие шаблоны,
что позволяет существенно сэкономить время на их написание и редактирование.

\section*{Лабораторная работа \#5}
\subsection*{Задание}
Реализовать возможность редактирование контента привилегированными пользователями.
\subsection*{Практическая часть}
Для упрощения реализации возможности редактирования контента привилегированными пользователями
решил ввести несколько полезных декораторов:
\begin{itemize}
\item login\_required --- который позволят доступ только залогиненным пользователям, если же
  пользователь не залогинен и шлет запрос --- отдается ошибка 401.
\item privileged\_required --- похожий декоратор, но разрешает доступ к странице только
  привилегированным пользователям, на основе флага <<privileged>> в сессии пользователя.
  Если непривилегированный пользователь пытается получить доступ к странице --- отдается
  ошибка 403.
\end{itemize}

Примеры кода представлены ниже:

\begin{lstlisting}
def login_required(f):
  @functools.wraps(f)
  def wrapped(*args, **kwargs):
    if not session.get('logged_in'):
      abort(401)
    return f(*args, **kwargs)
  return wrapped

def privileged_required(f):
  @functools.wraps(f)
  def wrapped(*args, **kwargs):
    if not session.get('privileged'):
      abort(403)
    return f(*args, **kwargs)
  return wrapped
\end{lstlisting}

Добавление новых декораторов позволило сократить объем кода за счет вынесения одинаковых
частей в них.

Так же в работе над этой лабораторной работой была обнаружена уязвимость, позволяющая
встроить произвольный код на страницу сайта. Она возникла из-за того, что я не экранировал
входные данные от пользователя, которые пришли в форме добавления новой записи.
Это было сделано осознано, потому что изначально предполагалось, что новый пост на
сайт сможет добавлять только привилегированный пользователь, который знает, что делает
и нет причин ему не доверять. Но потом я решил изменить и получается дал возможность любому
зарегистрированному пользователю исполнять произвольный код.

\subsection*{Выводы}
Довольно важно проводить аудит кода после существенных изменений
в изначальной идее сайта, потому что в коде могут остаться части, которые могу
представлять опасность при использовании сайта в текущем виде.

\section*{Лабораторная работа \#6}
\subsection*{Задание}
Реализовать возможность ставить like посту, добавлять его в избранное.
\subsection*{Практическая часть}
Для реализации возможности ставить like посту и добавлять его в избранное
были выделены два отдельных <<app.route>> целью которых было обновлять
информацию о том, что кому-то понравился пост на сервере.

Логику отрисовки и изменение подписей для ссылок решил реализовать на стороне
клиента с помощью JavaScript'a.

Схема работы получилась такая:
\begin{enumerate}
\item Пользователь нажимает на ссылку.
\item Из JavaScript'a асинхронно отправляется специально сформированный
  запрос на соответствующий <<app.route>>.
\item  Подпись к ссылке асинхронно обновляется.
\end{enumerate}

Таким образом шаги 2 и 3 должны выполняться параллельно, сразу обновляя контент
на странице, которую просматривает пользователь, давая понять, что его
like/добавление в избранное прошел успешно, а не его браузер из-за чего-то повис,
ожидая ответа от сервера.

Пример кода, который отвечает за эту часть логики:

\begin{lstlisting}[language=JavaScript]
function enjoyPost(id, enjoyType) {
  var request = new XMLHttpRequest();
  var requestPath = '/' + enjoyType + '/' + id;
  request.open('GET', requestPath);
  request.onload = function() {
    if( request.status != 200 ) {
      console.log('Request failed: ' + request.statusText)
      return;
    }
    var counter_elem = document.getElementById(getCounterName(id, enjoyType));
    var text_elem = document.getElementById(getTextName(id, enjoyType));
    if( enjoyType == 'like_post' ) {
      if( text_elem.innerHTML == 'like' ) {
        text_elem.innerHTML = 'unlike';
        counter_elem.innerHTML = parseInt(counter_elem.innerHTML, 10) + 1;
      }
      else {
        text_elem.innerHTML = 'like';
        counter_elem.innerHTML = parseInt(counter_elem.innerHTML, 10) - 1;
      }
    }
    else {
      if( text_elem.innerHTML == 'star' ) {
        text_elem.innerHTML = 'unstar';
        counter_elem.innerHTML = parseInt(counter_elem.innerHTML, 10) + 1;
      }
      else {
        text_elem.innerHTML = 'star';
        counter_elem.innerHTML = parseInt(counter_elem.innerHTML, 10) - 1;
      }
    }
  }
  request.send(null);
}
\end{lstlisting}

При написании JavaScript кода постарался использовать опыт, полученный при выполнении
лабораторной работы \#1 и не злоупотреблять колбеками для асинхронных функций.

В базе информация о любимых записях пользователя хранится хранится вместе с пользователем,
как множество из id постов, которые ему понравились.

\subsection*{Выводы}
Для реализации этой лабораторной работы пригодились знания из
лабораторной работы \#1. Кажется, обновление контента страницы
в зависимости от поведения пользователя правильно реализовывать
именно на стороне клиента JavaScript'ом, обновляя только ту часть страницы,
вид которой должен поменяться.

\section*{Лабораторная работа \#7}
\subsection*{Задание}
Подготовить/протестировать раскладку и работоспособность приложения в чистом
окружении.
\subsection*{Практическая часть}
Для тестирования раскладки и работоспособности приложения в чистом окружении
было решено создать новый lxc-контейнер, аналогичный тому в котором
велась разработка с нуля.

Вторым шагом было установление реальных зависимостей приложения. К счастью все дополнительные
пакеты ставил с помощью pip'a, поэтому с этим не было проблем. Используемые зависимости
были отделены от неиспользуемых (только для работы с CouchDB стояло три разных модуля, видимо 
остались того времени, когда я выбирал какой лучше использовать).

Реальных зависимостей для Python'a оказалось всего две (все остальное ставится как зависимость
к зависимости):
\begin{enumerate}
\item Flask
\item couchdbkit
\end{enumerate}

Возникла идея создать окружение virtualenv, но решил этого не делать, раз запуск
все равно планировался в изолированном контейнере и проблемы конфликта версий
модулей для разных приложений в нем стоять не должно.

Для подготовки операционной системы к запуску приложения пришлось поставить чуть больше
пакетов:
\begin{enumerate}
\item python
\item python-pip
\item python-dev (зачем-то нужен для couchdbkit'a)
\item couchdb
\item git
\end{enumerate}

В итоге скрипт деплоя и запуска приложения на Ubuntu 14.04 выглядит следующим
образом:
\begin{lstlisting}[language=Bash]
# install system dependencies
sudo apt-get install -y python python-pip python-dev couchdb git
# install python dependencies
sudo pip install Flask couchdbkit
# clone repo
git clone https://github.com/r3t/master-term1-webdev.git
cd master-term1-webdev/lab2
# init database views
python init_db.py
# run app
python funny.py
\end{lstlisting}


\subsection*{Выводы}
Попробовал почти на реальной задаче lxc-контейнеры и утилиты для работы с ними.
Впечатления скорее положительные, наверное, начну использовать их активнее.

\section*{Лабораторная работа \#8}
\subsection*{Задание}
Подготовить презентацию про Hadoop.
\subsection*{Практическая часть}
% copypaste from wiki:
% https://ru.wikipedia.org/wiki/Hadoop
Hadoop --- проект фонда Apache, свободно распространяемый набор утилит, библиотек и фреймворк для разработки
и выполнения распределённых программ, работающих на кластерах из сотен и тысяч узлов.
Используется для реализации поисковых и контекстных механизмов многих высоконагруженных веб-сайтов.
Разработан на Java в рамках вычислительной парадигмы mapreduce. 

Рассказ про хадуп решил разбить на три большие части:
\begin{itemize}
\item Рассказ про основные принципы хадупа. Попытался на реальных и понятных
  примерах пояснить почему эти принципы действительно важны и из-за чего решили
  сделать именно так, а не иначе.
\item Рассказ про компоненты системы, о том, что примерно происходит за кадром,
  как размечаются данные на реальном железе и с помощью каких механизмов происходит
  управление.
\item Короткий рассказ про про mapreduce и классический пример самой простой
  mapreduce задачи --- подсчет слов.
\end{itemize}

Для подготовки презентации пользовался официальной документацией по проекту и
презентациями по-настоящему продвинутых и реально разбирающихся в тонких моментах
работы системы людей.

В планах было рассказать немного о каких-нибудь полезных фреймворках и библиотеках
для написания mapreduce задачи (например MRJob, библиотека для языка программирования
Python, построенная на основе streaming'a), но позже решил отказаться от этой идеи, чтобы
не перегружать людей информацией сомнительной полезности.

\subsection*{Выводы}
При подготовке презентации открыл для себя много нового про внутреннее устройство
Hadoop'а, чем и попробовал поделится в своем рассказе.

\end{document}

